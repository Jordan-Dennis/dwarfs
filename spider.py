import abc 
import jax
import typing
import equinox
import functools
import dLux.utils 
#import numpy as np
import jax.numpy as np 
import matplotlib.pyplot as pyplot


Layer = typing.TypeVar("Layer")


class Spider(equinox.Module, abc.ABC):
    """
    An abstraction on the concept of an optical spider for a space telescope.
    These are the things that hold up the secondary mirrors. For example,

    Parameters
    ----------
    number_of_pixels: int
        The number of pixels along one edge of the image used to represent the 
        spider. 
    radius_of_spider: float, meters
        The physical width of the spider. For the moment it is assumed to be 
        embedded within a circular aperture.         
    width_of_image: float, meters
        The width of the image. If you wish to pad the array representation of
        the spider then set this to the padding factor multiplied by the 
        radius_of_spider parameter. 
    center_of_spicer: Array, meters 
        The [x, y] center of the spider.
    """  
    width_of_image: float
    number_of_pixels: int
    radius_of_spider: float
    centre_of_spider: float


    def __init__(
            self: Layer, 
            width_of_image: float,
            number_of_pixels: int, 
            radius_of_spider: float,
            centre_of_spider: float) -> Layer:
        """
        Parameters
        ----------
        number_of_pixels: int
            The number of pixels along one edge of the image used to represent 
            the spider. 
        radius_of_spider: float, meters
            The physical width of the spider. For the moment it is assumed to be 
            embedded within a circular aperture.         
        width_of_image: float, meters
            The width of the image. If you wish to pad the array representation of
            the spider then set this to the padding factor multiplied by the 
            radius_of_spider parameter. 
        center_of_spicer: Array, meters 
            The [x, y] center of the spider.
        """
        self.number_of_pixels = number_of_pixels
        self.width_of_image = np.asarray(width_of_image).astype(float)
        self.centre_of_spider = np.asarray(centre_of_spider).astype(float)
        self.radius_of_spider = np.asarray(radius_of_spider).astype(float)


    def _coordinates(self: Layer) -> float:
        """
        Generates a coordinate grid representing the positions of the pixels 
        relative to the centre of the spider. The representation that we 
        use is cartesian. 
    
        Returns 
        -------
        coordinates: float, meters
            The pixel coordinates.
        """
        pixel_scale = self.width_of_image / self.number_of_pixels
        pixel_centre = self.centre_of_spider / pixel_scale
        pixel_coordinates = dLux.utils.get_pixel_positions(
            self.number_of_pixels, pixel_centre[0], pixel_centre[1])
        return pixel_coordinates * pixel_scale  
 

    def _rotate(self: Layer, image: float, angle: float) -> float:
        """
        Rotate a set of coordinates by an amount angle. 
    
        Parameters
        ----------
        image: float, meters
            The physical coordinates for the pixel position as generated by 
            self._coordinates(). This should be a tensor with x then y along 
            the leading axis. 
        angle: float, radians
            The amount to rotate the coordinate system by. 

        Returns 
        -------
        coordinates: float, meters
            The rotate physical coordinate system. This will be a tensor with 
            x then y along the leading axis. 
        """
        coordinates = self._coordinates()
        rotation_matrix = np.array([
            [np.cos(angle), -np.sin(angle)], 
            [np.sin(angle), np.cos(angle)]])
        return np.apply_along_axis(np.matmul, 0, coordinates, rotation_matrix) 


    # TODO: This needs to be truncated to the radius of the spider. 
    # @functools.partial(jax.vmap, in_axes=(None, 0, None))
    def _strut(self: Layer, angle: float, width: float) -> float:
        """
        Generates a representation of a single strut in the spider. This is 
        more complex than you might imagine since the strut can point in 
        any direction. 

        Parameters
        ----------
        angle: float, radians
            The angle that this strut points as measured from the positive 
            x-axis in radians. 
        width: float, meters
            The width of the strut in meters. Note: a large amount of effort 
            is made to make the edge soft so that autodiff does not achieve 
            infinite gradients and that means that in the output the exact 
            edge is not well defined.

        Returns
        -------
        strut: float
            The soft edged strut. 
        """
        coordinates = self._rotate(self._coordinates(), angle)
        distance = np.abs(coordinates[1]).at[coordinates[0] > 0].set(np.inf)
        spider = self._sigmoid(distance, width / 2.)
        return spider        

    
    # TODO: 
    def _sigmoid(self: Layer, distance: float, width: float) -> float:
        """
        The name is a misnomer but it has been kept for legacy reasons. 
        This is a routine that is used in the soft edging of the images. 
        """
        steepness = self.number_of_pixels
        return (np.tanh(steepness * (distance - width)) + 1.) / 2.


    @abc.abstractmethod
    def _spider(self: Layer) -> float:
        pass 

    
    @abc.abstractmethod
    def __call__(self: Layer, params: dict) -> dict:
        pass 


class UniformSpider(Spider):
    number_of_struts: int
    width_of_struts: float
    rotation: float


    def __init__(
            self: Layer, 
            width_of_image: float,
            number_of_pixels: int, 
            radius_of_spider: float,
            centre_of_spider: float,
            number_of_struts: int, 
            width_of_struts: float, 
            rotation: float) -> Layer:
        super().__init__(
            width_of_image, 
            number_of_pixels, 
            radius_of_spider,
            centre_of_spider)
        self.number_of_struts = number_of_struts
        self.rotation = np.asarray(rotation).astype(float)
        self.width_of_struts = np.asarray(width_of_struts).astype(float)


    def _spider(self: Layer) -> float:
        angles = np.linspace(0, 2 * np.pi, self.number_of_struts, 
            endpoint=False)
        angles += self.rotation

        spider = np.ones((self.number_of_pixels, self.number_of_pixels))
        for angle in angles:
            spider *= self._strut(angle, self.width_of_struts)

        # TODO: This needs to be moved to the outside. 
        coordinates = self._coordinates()
        radial_coordinates = np.hypot(coordinates[0], coordinates[1])

        radial_distance = np.abs(radial_coordinates - self.radius_of_spider)\
            .at[radial_coordinates > self.radius_of_spider]\
            .set(-np.inf)

        soft_edge = self.width_of_image / self.number_of_pixels
        radial_soft_edge = self._sigmoid(radial_distance, soft_edge)

        return radial_soft_edge * spider
        # return self._strut(angles).sum(axis=0) / self.number_of_struts
        
 
    def __call__(self: Layer, params: dict) -> dict:
        aperture = self._spider()
        wavefront = params["Wavefront"]
        wavefront = wavefront\
            .set_amplitude(wavefront.get_amplitude() * aperture)\
            .set_phase(wavefront.get_phase() * aperture)
        params["Wavefront"] = wavefront
        return params

spider = UniformSpider(1., 1024, .5, [0., 0.], 7, 0.1, 0.)._spider()
pyplot.imshow(spider)
pyplot.colorbar()
pyplot.show()
